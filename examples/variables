#!/usr/local/bin/shale

// Variables.

// There are two types of variables: simple and namespace.
//
// Here are some examples of variable names
//
//  i                               <-- simple variable, standard
//  loopCounter_2                   <-- simple variable, standard
//  "_factorial_loop_counter"$      <-- simple variable, user-defined (note the $ operator)
//  3$                              <-- simple variable, user-defined
//  i ns::                          <-- namespace variable
//  i.value j.value:: a::           <-- namespace variable
//
// Simple variables are for general use within code fragments,
// and namespace variables are global and are not tied to a code fragment.
//
// All variables are limited in length to 63 characters.
//
// Referring to a variable pushes the variable name on the stack.
// It does not push the value on the stack. It always pushes the name on the stack.
//
// In this file we'll discuss simple variables. See the "namespaces"
// file for a discussion of namespace variables.



// Simple variable names.

// There are two ways of creating simple variable names: standard and user-defined.
//
// Standard names.
//
// A standard variable name starts with an alphabetic character followoed
// by zero of more alphanumeric or underscoee characters. You can't create
// a standard variable name that is the same as one of shale's 30 or so operators,
// like if or while, but everything else is fine. If you really want a variable called if
// then use a user-defined variable.
//
// User-defined names.
//
// You can create any variable name you like by using the $ operator.
// This takes a number (integer or floating point) or a string on the stack
// and turns it into a variable name. So to get that if variable name, use "if"$.



// The scope of a simple variable.

// A simple variable created in a code fragment is accessible to all code fragments
// that this and subsequent fragments executes. When the code fragment exits
// the variable is removed.
//
// A variable's scope is defined by the code fragment's execution,
// and not the lexical scope of the fragment as it is in C.
// This really impacts "functions". shale doesn't have functions. It has
// the ability to assign a code fragment to a variable.
//
// A variable defined in a code fragment will hide a
// variable of the same name created in an enclosing fragment.
//
// Here's how this plays out.
//
// The easiest thing to see is some nested fragments.

i var
i 123 =
i 100 > {
  i var           // hides the "123" i
  i 987 =
  i println       // 987
  i 987 == {
    i var         // hides the "987" i
    i 3.141 =
    i println     // 3.141
  } ifthen
} {
  i var           // hides the "123" i
  i "abc123" =
  i println       // abc123 (won't be output)
} if
i println         // 123

// When if comes to "functions" it is important to remember
// that shale doesn't have functions but rather you can assign
// a code fragment to a variable and execute that code fragment.
//
// Here's how this plays out.

printi var
printi {
  i println
} =

cf var
cf {
  i var
  i 987 =
  printi()
} =

i 123 =
printi()      // 123
cf()          // 987

// It is important to recognise that executing printi() from within cf()
// is simply executing another code fragment (that is "i println").
// There is no such thing as a function in shale, although I make it look
// like there is. There's more on this in the functions file.



// The problems.

// Pushing a variable's name on the stack rather than its value can lead
// to some problems when calling functions. I know shale doesn't have functions,
// but I'll still refer to them like this. Everything I say here also
// applies to any code fragment, but it is most likely to show up
// when calling functions. And it all relates to passing values in to,
// or out from, functions.
//
// Passing values in to a function.
//
// Consider the following code
//
//  i var
//  i 123 =
//  i function()
//
// where function() is meant to perform some calculation based on the
// passed-in value. Problem is, function() is not getting a value, it is
// getting a variable name. function() might create its own variable called i,
// hiding the calling code's i.
//
// There're a couple of ways of dealing with this.
//
// The first way is to push the variable's value rather than its name.
// You do with the value or .value operator. So you could do:
//
//  i.value function()
//
// The second way is for function() to call the value or .value operator before
// creating any of its own variables, thereby turning any name into its value.
// Unfortunately, this on;y works when the function()
// has one argument on the stack. For two or more arguments this cannot
// be relied upon. So I call this deprecated.
//
// The third way is to use user-defined variables along with a coding standard,
// like the Barr Group standard, where there are clear rules around how you
// name all variables.
//
// Passing values out of a function.
//
// If your function returns a result or results on the stack then always
// use the value or .value operator to push local variable's values rather
// than their names.
