#!/usr/local/bin/shale

// This solves a sudoku with:
//  row/column/3x3box constraints (standard sudoku)
//  row/column/irregular, or jigsaw, region constraints
// optionally with any combination of these additional constraints:
//  Chess King's move
//  Chess Kinght's move
//  non-consecutive
//  arrow
//  thermo
//  kropki dot
//  negative kropki dot
//  XV
//  negative XV
//  killer cages
//  top-left to bottom-right diagonal
//  botton-left to top-right diagonal
//  odd or even cells
//  disjoint sets
//  palindrome lines
// Threads may also be used to shorten the time to the solution.

// It is based on the python code from the Computerphile video
//  https://www.youtube.com/watch?v=G_UYXzGuqvM
// The sudoku example from this video is used below, along with
// several Cracking the Cryptic examples and one from Andrew Stuart.

// This script comes with several pre-defined sudokus to solve, which you
// select by adding s={n} to the command line. If you don't specify s={n} then
// you will be presented with the list of pre-defined sudokus and some other details
// about running this script.

// To use threads, add threads=n to the command line, where n (>= 2) is the maximum number
// of threads. Add progress=true to the command line to get a view of the threads in use.

// You can also add your own sudoku to solve by skipping down towards the end of this file
// and adding it where indicated, and add s=12 to the command line. There are instructions
// on what and how to add a sudoku, and you can check the examples I've included
// that immediately precede that section.

time library

startTime vars:: dup var now time::() =

whichSudoku var

s initialised {
  whichSudoku s =
} {
  "You can choose to solve one of several sudokus by adding s=n to the command line," println
  "where n is" println
  "  1: standard sudoku from Computerphile (the default)" println
  "  2: standard sudoku from Cracking the Cryptic" println
  "  3: standard sudoku from Cracking the Cryptic, with Knight's move constraint" println
  "  4: standard sudoku from Cracking the Cryptic" println
  "  5: irregular sudoku from Cracking the Cryptic" println
  "  6: irregular sudoku from Andrew Stuart" println
  "  7: regular sudoku with an arrow constraint, from Cracking the Cryptic." println
  "  8: regular sudoku with a thermo constraint, from Cracking the Cryptic." println
  "  9: regular sudoku with King's and Knight's move and non-consecutive constraints. Cracking the Cryptic's Miracle sudoku." println
  " 10: irregular sudoku with a kropki dot constraint, from Cracking the Cryptic." println
  " 11: regular sudoku with negative kropki dot and both main diagonal constraints, from Cracking the Cryptic." println
  " 12: empty and waiting for you to fill it in with an unsolved sudoku. Check towards the end of this file for details." println
  "" println
  "You can enable the use of threads by adding threads=n to the command line," println
  "where n is the maximum number of threads to use. Add progress=true to see thread details." println
  "" println
  "You can also enable colour output by adding colour=true or color=true to the command line." println
  "" println
  "For example," println
  file arg:: shale:: "  %s s=6 colour=true threads=4 progress=true\n" printf
  "will solve Andrew Stuart's irregular sudoku using 4 threads" println
  "" println
  whichSudoku 1 =
} if

// This sets up the colour map for irregular sudokus.
1 colour:: dup var 31 =
2 colour:: dup var 32 =
3 colour:: dup var 33 =
4 colour:: dup var 34 =
5 colour:: dup var 35 =
6 colour:: dup var 36 =
7 colour:: dup var 31 =
8 colour:: dup var 32 =
9 colour:: dup var 33 =

// Helper function to print seconds as days, hours, minutes and seconds.
dhms fn:: dup var {
  n dup var swap =
  ds dup var n int 86400 / =
  hs dup var n int 3600 / 24 % =
  ms dup var n int 60 / 60 % =
  ss dup var n ds 86400 * hs 3600 * ms 60 * + + - =

  ds { ds "%dd" printf } ifthen
  hs { ds { " " print } ifthen hs "%dh" printf } ifthen
  ms { ds hs or { " " print } ifthen ms "%dm" printf } ifthen
  ss { ds hs or ms or { " " print } ifthen ss "%0.3fs" printf } ifthen
} =

// Prints the sudoku grid.
printGrid dup var {
  r var
  c var
  doColour var
  irregular var
  region var

  colour initialised {
    doColour colour =
  } {
    color initialised {
      doColour color =
    } {
      doColour false =
    } if
  } if
  irregular 0 0:: regions:: initialised =

  "" println

  r 0 =
  { r 9 < } {
    c 0 =
    { c 9 < } {
      doColour {
        irregular {
          region r.value c.value:: regions:: =
          region.value colour:: 0x1b "%c[1;%dm" printf
        } {
          r 3 / c 3 / + 1 + 2 % 3 * 31 + 0x1b "%c[1;%dm" printf
        } if
      } ifthen
      r.value c.value:: grid:: dup 0 == { pop " ." } { " %d" } if printf
      doColour {
        0x1b "%c[0m" printf
      } ifthen
      c++
    } while
    "" println
    r++
  } while
} =

printSolution fn:: dup var {
  r var
  c var
  f var
  doColour var
  irregular var
  region var

  colour initialised {
    doColour colour =
  } {
    color initialised {
      doColour color =
    } {
      doColour false =
    } if
  } if
  irregular 0 0:: regions:: initialised =

  "" println

  r 0 =
  { r 9 < } {
    f 1 =
    c 0 =
    { c 9 < } {
      doColour {
        irregular {
          region r.value c.value:: regions:: =
          region.value colour:: 0x1b "%c[1;%dm" printf
        } {
          r 3 / c 3 / + 1 + 2 % 3 * 31 + 0x1b "%c[1;%dm" printf
        } if
      } ifthen
      r.value$ f / 10 % dup 0 == { pop " ." } { " %d" } if printf
      doColour {
        0x1b "%c[0m" printf
      } ifthen
      f f 10 * =
      c++
    } while
    "" println
    r++
  } while

  "Solution in " print now time::() startTime vars:: - 1000.0 / dhms fn::() "" println
} =

// Assign the cell values to one row of the grid.
setRow dup var {
  8$ dup var swap =   // cell 9 of the row
  7$ dup var swap =   // cell 8 of the row
  6$ dup var swap =   // ...
  5$ dup var swap =
  4$ dup var swap =
  3$ dup var swap =
  2$ dup var swap =
  1$ dup var swap =   // ...
  0$ dup var swap =   // cell 1 of the row
  r dup var swap =    // the row number
  ns dup var swap &=  // the namespace to use
  i var               // loop counter

  r 0 < r 8 > or {
    r "Illegal row %d\n" printf
    1 exit
  } ifthen

  i 0 =
  { i 9 < } {
    i.value$ 0 < i.value$ 9 > or {
      i r i.value$ "Illegal value %d specified for r%dc%d\n" printf
      1 exit
    } ifthen
    r.value i.value:: ns->:: defined not {    // define this grid cell if not already defined
      r.value i.value:: ns->:: var
    } ifthen
    r.value i.value:: ns->:: i.value$ =       // assign the value to the grid cell
    i++
  } while
} =

regionChecker fn:: var

// Standard 3x3 box region checker.
standardRegions fn:: dup var { function
  r var
  c var
  i var
  j var

  r row row 3 % - =
  c col col 3 % - =
  i 0 =
  { i 3 < } {
    j 0 =
    { j 3 < } {
      f c j + 10 + $ =
      r i + $ f / 10 % num == { false return } ifthen
      j++
    } while
    i++
  } while

  true
} =

// Irregular region checker.
irregularRegions fn:: dup var { function
  region var
  i var

  region row.value col.value:: regions:: =   // The region we are in.

  i 0 =
  { i 9 < } {
    i.value r:: region.value:: region:: value$ i.value c:: region.value:: region:: 10 + $ / 10 % num == {
      false return
    } ifthen
    i++
  } while

  true
} =

// Convert the regions:: namespace into something a little more cpu-time friendly.
// Only optimise if there are irregular regions defined.
optimiseRegions dup var {
  0 0:: regions:: initialised {
    region var
    r var
    c var
    i var

    region 1 =
    { region 10 < } {
      i 0 =
      r 0 =
      { r 9 < } {
        c 0 =
        { c 9 < } {
          r.value c.value:: regions:: region == {
            i.value r:: region.value:: region:: dup var r =
            i.value c:: region.value:: region:: dup var c =
            i++
          } ifthen
          c++
        } while
        r++
      } while
      i 9 != {
        i region "Region %d contains the wrong number of cells (%d)\n" printf
        1 exit
      } ifthen
      region++
    } while
  } ifthen
} =

// Start a new arrow (circle) at the given row and column.
// If several arrows start from the same circle then add them as seperate
// new arrows from that same circle cell.
newArrow dup var {
  0$ dup var swap =  // column
  1$ dup var swap =  // row
  arrow var
  i var

  // Allocate a new arrow number.
  count arrows:: initialised not {
    count arrows:: dup var 0 =
  } {
    count arrows::++
  } if
  arrow count arrows:: =

  // Every cell can have multiple arrows eminating from it.
  circleCount 1$.value:: 0$.value:: arrows:: initialised not {
    circleCount 1$.value:: 0$.value:: arrows:: dup var 0 =
  } {
    circleCount 1$.value:: 0$.value:: arrows::++
  } if
  i circleCount 1$.value:: 0$.value:: arrows:: =

  arrow i.value:: 1$.value:: 0$.value:: arrows:: dup var arrow =    // Tag this cell with the arrow number.
  cells arrow.value:: arrows:: dup var 0 =                          // Number of cells this arrow contains.
  row arrow.value:: arrows:: dup var 1$ =                           // Save the location of this circle.
  column arrow.value:: arrows:: dup var 0$ =
} =

// Add a cell to the current arrow. Each cell can be part of multiple arrows.
arrowCell dup var {
  0$ dup var swap =  // column
  1$ dup var swap =  // row
  arrow var
  cell var
  i var

  arrow count arrows:: =                // Current arrow number.
  cell cells arrow.value:: arrows:: =   // Number of cells in this arrow so far.
  cells arrow.value:: arrows::++        // Increment the number of cells.

  cellCount 1$.value:: 0$.value:: arrows:: initialised not {
    cellCount 1$.value:: 0$.value:: arrows:: dup var 0 =
  } {
    cellCount 1$.value:: 0$.value:: arrows::++
  } if
  i cellCount 1$.value:: 0$.value:: arrows:: =

  arrow i.value:: 1$.value:: 0$.value:: arrows:: dup var arrow =
  row cell.value:: arrow.value:: arrows:: dup var 1$ =
  column cell.value:: arrow.value:: arrows:: dup var 0$ =
} =

// Start a new thermo (bulb) at the given row and column.
// If several thermos start from the same bulb then add them as seperate
// new thermos from that same bulb cell.
newThermo dup var {
  0$ dup var swap =  // column
  1$ dup var swap =  // row
  thermo var
  p var

  // Allocate a new thermo number.
  p count thermos:: &=
  p-> initialised not {
    p-> dup var 0 =
  } {
    p->++
  } if
  thermo p-> =

  // Add this thermo to the cell's thermo list.
  p thermoCount 1$.value:: 0$.value:: thermos:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  p->value thermoList:: 1$.value:: 0$.value$:: thermos:: dup var thermo =
  p->++

  p thermo.value thermos:: &=
  row 0:: p->:: dup var 1$ =
  col 0:: p->:: dup var 0$ =
  cells p->:: dup var 1 =
  ordinal 1$.value:: 0$.value:: p->:: dup var 0 =
} =

// Add a cell to the current thermo. Each cell can be part of multiple thermos.
thermoCell dup var {
  0$ dup var swap =  // column
  1$ dup var swap =  // row
  thermo var
  p var
  i var

  thermo count thermos:: =                // Current thermo number.
  p thermo.value thermos:: &=
  i cells p->:: =                         // Number of cells in this thermo so far.
  row i.value:: p->:: dup var 1$ =
  col i.value:: p->:: dup var 0$ =
  cells p->::++
  ordinal 1$.value:: 0$.value:: p->:: dup var i =

  p thermoCount 1$.value:: 0$.value:: thermos:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  p->value thermoList:: 1$.value:: 0$.value$:: thermos:: dup var thermo =
  p->++
} =

// Join two cells with a black kropki dot.
blackDot dup var {
  c2 dup var swap =
  r2 dup var swap =
  c1 dup var swap =
  r1 dup var swap =
  p var

  p count r1.value:: c1.value:: blackDot:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r1.value:: c1.value:: blackDot:: dup var r2 =
  col p->value:: r1.value:: c1.value:: blackDot:: dup var c2 =
  p->++

  p count r2.value:: c2.value:: blackDot:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r2.value:: c2.value:: blackDot:: dup var r1 =
  col p->value:: r2.value:: c2.value:: blackDot:: dup var c1 =
  p->++
} =

// Join two cells with a white kropki dot.
whiteDot dup var {
  c2 dup var swap =
  r2 dup var swap =
  c1 dup var swap =
  r1 dup var swap =
  p var

  p count r1.value:: c1.value:: whiteDot:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r1.value:: c1.value:: whiteDot:: dup var r2 =
  col p->value:: r1.value:: c1.value:: whiteDot:: dup var c2 =
  p->++

  p count r2.value:: c2.value:: whiteDot:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r2.value:: c2.value:: whiteDot:: dup var r1 =
  col p->value:: r2.value:: c2.value:: whiteDot:: dup var c1 =
  p->++
} =

// Join two cells with an X.
X dup var {
  c2 dup var swap =
  r2 dup var swap =
  c1 dup var swap =
  r1 dup var swap =
  p var

  p count r1.value:: c1.value:: X:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r1.value:: c1.value:: X:: dup var r2 =
  col p->value:: r1.value:: c1.value:: X:: dup var c2 =
  p->++

  p count r2.value:: c2.value:: X:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r2.value:: c2.value:: X:: dup var r1 =
  col p->value:: r2.value:: c2.value:: X:: dup var c1 =
  p->++
} =

// Join two cells with a V.
V dup var {
  c2 dup var swap =
  r2 dup var swap =
  c1 dup var swap =
  r1 dup var swap =
  p var

  p count r1.value:: c1.value:: V:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r1.value:: c1.value:: V:: dup var r2 =
  col p->value:: r1.value:: c1.value:: V:: dup var c2 =
  p->++

  p count r2.value:: c2.value:: V:: &=
  p-> initialised not {
    p-> dup var 0 =
  } ifthen
  row p->value:: r2.value:: c2.value:: V:: dup var r1 =
  col p->value:: r2.value:: c2.value:: V:: dup var c1 =
  p->++
} =

// Create a new killer cage. This takes the cage sum as argument.
// If the cage has no sum given, then use 0 as the argument.
killerCage dup var {
  n dup var swap =
  cage var

  count killer:: initialised not {
    count killer:: dup var 0 =
  } {
    count killer::++
  } if
  cage count killer:: =                       // Unique cage number.

  sum cage.value:: killer:: dup var n =       // Cage sum. 0 = no sum specified.
  count cage.value:: killer:: dup var 0 =     // Number of cells in this cage.
} =

// Add a cell to the current killer cage.
killerCell dup var {
  c dup var swap =
  r dup var swap =
  cage var
  i var

  cage count killer:: =
  i count cage.value:: killer:: =             // Current cage number.
  r.value c.value:: killer:: initialised {
    c r "Cell %d %d is already part of a killer cage.\n" printf
    0 exit
  } ifthen
  r.value c.value:: killer:: dup var cage =   // The cage number this cell is part of.
  row i.value:: cage.value:: killer:: dup var r =
  col i.value:: cage.value:: killer:: dup var c =
  count cage.value:: killer::++
} =

// Odd and even cells.
oddCell dup var {
  c dup var swap =
  r dup var swap =

  r.value c.value:: oddEven:: dup initialised {
    c r "Cell at %d, %d already set as odd or even\n" printf
    1 exit
  } ifthen

  dup var 1 =
} =

evenCell dup var {
  c dup var swap =
  r dup var swap =

  r.value c.value:: oddEven:: dup initialised {
    c r "Cell at %d, %d already set as odd or even\n" printf
    1 exit
  } ifthen

  dup var 0 =
} =

// Used to build palindrome lines.
same dup var {
  c2 dup var swap =
  r2 dup var swap =
  c1 dup var swap =
  r1 dup var swap =

  row r1.value:: c1.value:: same:: dup var r2 =
  col r1.value:: c1.value:: same:: dup var c2 =
  row r2.value:: c2.value:: same:: dup var r1 =
  col r2.value:: c2.value:: same:: dup var c1 =
} =

constraint fn:: dup var { function true } =

kingsMoveConstraint fn:: dup var { function
  nr var
  nc var

  // Check Kings's move 1 left and 1 up and down.
  nc col 1 - =
  nc 0 >= {
    nr row 1 - =
    nr 0 >= {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
    nr row 1 + =
    nr 9 < {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
  } ifthen

  // Check Kings's move 1 right and 1 up and down.
  nc col 1 + =
  nc 9 < {
    nr row 1 - =
    nr 0 >= {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
    nr row 1 + =
    nr 9 < {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
  } ifthen

  true
} =

knightsMoveConstraint fn:: dup var { function
  nr var
  nc var

  // Check Knight's move 2 left and 1 up and down.
  nc col 2 - =
  nc 0 >= {
    nr row 1 - =
    nr 0 >= {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
    nr row 1 + =
    nr 9 < {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
  } ifthen

  // Check Knight's move 1 left and 2 up and down.
  nc col 1 - =
  nc 0 >= {
    nr row 2 - =
    nr 0 >= {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
    nr row 2 + =
    nr 9 < {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
  } ifthen

  // Check Knight's move 1 right and 2 up and down.
  nc col 1 + =
  nc 9 < {
    nr row 2 - =
    nr 0 >= {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
    nr row 2 + =
    nr 9 < {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
  } ifthen

  // Check Knight's move 2 right and 1 up and down.
  nc col 2 + =
  nc 9 < {
    nr row 1 - =
    nr 0 >= {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
    nr row 1 + =
    nr 9 < {
      nr.value$ nc 10 + $ / 10 % num == { false return } ifthen
    } ifthen
  } ifthen

  true
} =

nonconsecutiveConstraint fn:: dup var { function
  nr var
  nc var
  cell var

  // Check left.
  nc col 1 - =
  nc 0 >= {
    cell row.value$ nc 10 + $ / 10 % =
    cell 0 != {
      num cell 1 - == { num cell 1 + == } or { false return } ifthen
    } ifthen
  } ifthen

  // Check right.
  nc col 1 + =
  nc 9 < {
    cell row.value$ nc 10 + $ / 10 % =
    cell 0 != {
      num cell 1 - == { num cell 1 + == } or { false return } ifthen
    } ifthen
  } ifthen

  // Check up.
  nr row 1 - =
  nr 0 >= {
    cell nr.value$ col 10 + $ / 10 % =
    cell 0 != {
      num cell 1 - == { num cell 1 + == } or { false return } ifthen
    } ifthen
  } ifthen

  // Check down.
  nr row 1 + =
  nr 9 < {
    cell nr.value$ col 10 + $ / 10 % =
    cell 0 != {
      num cell 1 - == { num cell 1 + == } or { false return } ifthen
    } ifthen
  } ifthen

  true
} =

arrowConstraint fn:: dup var { function
  arrow var
  r var
  c var
  v var
  i var
  circle var
  sum var

  // Is this an arrow circle?
  circleCount row.value:: col.value:: arrows:: initialised {
    // Yes.
    i 0 =
    { i circleCount row.value:: col.value:: arrows:: <= } {
      sum arrow i.value:: row.value:: col.value:: arrows:: sumArrow fn::() =
      sum 0 > sum num != and { false return } ifthen    // If we have a sum and it is wrong, return false.
      i++
    } while
  } {
    // No.
    // Is this cell part of an arrow?
    cellCount row.value:: col.value:: arrows:: initialised {
      // Yes.
      i 0 =
      { i cellCount row.value:: col.value:: arrows:: <= } {
        // Does the circle have a value?
        arrow arrow i.value:: row.value:: col.value:: arrows:: =
        r row arrow.value:: arrows:: =
        c column arrow.value:: arrows:: =
        circle r.value$ c 10 + $ / 10 % =
        circle 0 != {
          // Yes.
          v row.value$ =
          row.value$ v num col 10 + $ * + =                   // Temporarily put the number in the grid.
          sum arrow.value sumArrow fn::() =
          row.value$ v =                                      // Take if out again.
          sum 0 > sum circle != and { false return } ifthen   // If we have a sum and it is wrong, return false.
        } ifthen
        i++
      } while
    } ifthen
  } if

  true
} =

sumArrow fn:: dup var {
  arrow dup var swap =
  i var
  r var
  c var
  cell var
  sum var

  sum 0 =
  i 0 =
  { i cells arrow.value:: arrows:: < } {
    r row i.value:: arrow.value:: arrows:: =
    c column i.value:: arrow.value:: arrows:: =
    cell r.value$ c 10 + $ / 10 % =
    cell 0 == { sum -1 = break } ifthen
    sum sum cell + =
    i++
  } while

  sum.value
} =

// This is a thermo constraint.
thermoConstraint fn:: dup var { function
  thermo var
  p var
  i var
  n var
  o var
  v var

  // Is this cell part of some thermos?
  p row.value col.value:: thermos:: &=
  thermoCount p->:: initialised {
    // Yes. Go through them all.
    n thermoCount p->:: =
    i 0 =
    { i n < } {
      // First check that num is within the bounds for this cell within this thermo.
      thermo i.value thermoList:: row.value:: col.value:: thermos:: =
      o ordinal row.value:: col.value:: thermo.value:: thermos:: =
      num o <= { false return } ifthen
      num o 10 + cells thermo.value:: thermos:: - > { false return } ifthen

      // It passed the initial tests. Now put the number in the grid and check the thermo manually.
      v row.value$ =
      row.value$ v num col 10 + $ * + =
      thermoIsBad fn::() row.value$ v = { false return } ifthen
      i++
    } while
  } ifthen

  true
} =

// Returns true if the given thermo is incorrect, false otherwise.
thermoIsBad fn:: dup var { function
  i var
  n var
  r var
  c var
  l var
  v var

  l 0 =
  n cells thermo.value:: thermos:: =
  i 0 =
  { i n < } {
    r row i.value:: thermo.value:: thermos:: =
    c col i.value:: thermo.value:: thermos:: =
    v r.value$ c 10 + $ / 10 % =
    v 0 == { false return } ifthen
    v l <= { true return } ifthen
    l v =
    i++
  } while

  false
} =

// Kropi constraint.
kropkiConstraint fn:: dup var { function
  i var
  n var
  r var
  c var
  p var
  cell var

  // Does this cell have any black dots?
  count row.value:: col.value:: blackDot:: initialised {
    // Yes. Can we reject this value immediately?
    num 5 == { num 7 == { num 9 == } or } or { false return } ifthen

    // Go through the related cells and check the 1:2 ratio.
    n count row.value:: col.value:: blackDot:: =
    i 0 =
    { i n < } {
      p i.value row.value:: col.value:: blackDot:: &=
      r row p->:: =
      c col p->:: =
      cell r.value$ c 10 + $ / 10 % =
      cell 0 != {
        num cell 2 * != { cell num 2 * != } and { false return } ifthen
      } ifthen
      i++
    } while
  } ifthen

  // Does this cell have any white dots?
  count row.value:: col.value:: whiteDot:: initialised {
    // Yes. Go through the related cells and check they are consecutive.
    n count row.value:: col.value:: whiteDot:: =
    i 0 =
    { i n < } {
      p i.value row.value:: col.value:: whiteDot:: &=
      r row p->:: =
      c col p->:: =
      cell r.value$ c 10 + $ / 10 % =
      cell 0 != {
        num cell 1 + != { cell num 1 + != } and { false return } ifthen
      } ifthen
      i++
    } while
  } ifthen

  true
} =

// Negative-Kropki constraint.
negativeKropkiConstraint fn:: dup var { function
  c var

  // Does this cell have any black dots?
  count row.value:: col.value:: blackDot:: initialised { true return } ifthen

  // Does this cell have any white dots?
  count row.value:: col.value:: whiteDot:: initialised { true return } ifthen

  // Check right.
  col 8 < {
    c row.value$ col 11 + $ / 10 % =
    c 0 != { num c 1 - == { num c 1 + == { num c 2 * == { num 2 * c == } or } or } or } and { false return } ifthen
  } ifthen

  // Check down.
  row 8 < {
    c row 1 + $ col 10 + $ / 10 % =
    c 0 != { num c 1 - == { num c 1 + == { num c 2 * == { num 2 * c == } or } or } or } and { false return } ifthen
  } ifthen

  // Check left.
  col 0 > {
    c row.value$ col 9 + $ / 10 % =
    c 0 != { num c 1 - == { num c 1 + == { num c 2 * == { num 2 * c == } or } or } or } and { false return } ifthen
  } ifthen

  // Check up.
  row 0 > {
    c row 1 - $ col 10 + $ / 10 % =
    c 0 != { num c 1 - == { num c 1 + == { num c 2 * == { num 2 * c == } or } or } or } and { false return } ifthen
  } ifthen

  true
} =

// XV constraint.
xvConstraint fn:: dup var { function
  i var
  n var
  r var
  c var
  p var
  cell var

  // Does this cell have any X's?
  count row.value:: col.value:: X:: initialised {
    // Yes. Go through the related cells and check they add to 10.
    n count row.value:: col.value:: X:: =
    i 0 =
    { i n < } {
      p i.value row.value:: col.value:: X:: &=
      r row p->:: =
      c col p->:: =
      cell r.value$ c 10 + $ / 10 % =
      cell 0 != {
        num cell + 10 != { false return } ifthen
      } ifthen
      i++
    } while
  } ifthen

  // Does this cell have any V's?
  count row.value:: col.value:: V:: initialised {
    // Yes. Go through the related cells and check they add to 5.
    n count row.value:: col.value:: V:: =
    i 0 =
    { i n < } {
      p i.value row.value:: col.value:: V:: &=
      r row p->:: =
      c col p->:: =
      cell r.value$ c 10 + $ / 10 % =
      cell 0 != {
        num cell + 5 != { false return } ifthen
      } ifthen
      i++
    } while
  } ifthen

  true
} =

// Negative-XV helper routine.
negativeXVCheck fn:: dup var {
  cond dup var swap =
  p var
  i var
  n var
  ret var

  ret true =
  px-> initialised {
    n px-> =
    i 0 =
    { i n < } {
      p i.value row.value:: col.value:: X:: &=
      cond() {
        ret false =       // There is an X between the two cells, so no need to check the negative constraint.
        break
      } ifthen
      i++
    } while
  } ifthen

  ret {
    pv-> initialised {
      n pv-> =
      i 0 =
      { i n < } {
        p i.value row.value:: col.value:: V:: &=
        cond() {
          ret false =     // There is a V between the two cells, so no need to check the negative constraint.
          break
        } ifthen
        i++
      } while
    } ifthen
  } ifthen

  ret.value
} =

// Negative-XV constraint.
negativeXVConstraint fn:: dup var { function
  r var
  c var
  v var
  px dup var count row.value:: col.value:: X:: &=
  pv dup var count row.value:: col.value:: V:: &=

  // Check up.
  c col 1 - =
  c 0 >= {
    // Is there an X or V between row/col and row/c.
    { row p->:: row == { col p->:: c == } and } negativeXVCheck fn::() {
      // We need to check.
      v row.value$ c 10 + $ / 10 % =
      v 0 != { num v + 10 == { num v + 5 == } or } and { false return } ifthen
    } ifthen
  } ifthen

  // Check right.
  r row 1 + =
  r 9 < {
    // Is there an X or V between row/col and r/col.
    { row p->:: r == { col p->:: col == } and } negativeXVCheck fn::() {
      // We need to check.
      v r.value$ col 10 + $ / 10 % =
      v 0 != { num v + 10 == { num v + 5 == } or } and { false return } ifthen
    } ifthen
  } ifthen

  // Check down.
  c col 1 + =
  c 9 < {
    // Is there an X or V between row/col and row/c.
    { row p->:: row == { col p->:: c == } and } negativeXVCheck fn::() {
      // We need to check.
      v row.value$ c 10 + $ / 10 % =
      v 0 != { num v + 10 == { num v + 5 == } or } and { false return } ifthen
    } ifthen
  } ifthen

  // Check left.
  r row 1 - =
  r 0 >= {
    // Is there an X or V between row/col and r/col.
    { row p->:: r == { col p->:: col == } and } negativeXVCheck fn::() {
      // We need to check.
      v r.value$ col 10 + $ / 10 % =
      v 0 != { num v + 10 == { num v + 5 == } or } and { false return } ifthen
    } ifthen
  } ifthen

  true
} =

// Initialise some of the allowable digits in killer cages.
initKillerDigits dup var {
   3 2:: digits:: killer:: dup var 6 =    // 3 in 2 cells can be 1+2. 1 << 1 = 0b010 and 1 << 2 = 0b0100. add these together and you get 0b0110 = 6.
   4 2:: digits:: killer:: dup var 10 =
   5 2:: digits:: killer:: dup var 30 =   // 5 in 2 cells can be 1+4 or 2+3. 1 << 1 = 0b010, 1 << 4 = 0b010000, 1 << 2 = 0b0100, 1 << 3 = 0b01000, hence 0b011110 = 30
   6 2:: digits:: killer:: dup var 54 =
   6 3:: digits:: killer:: dup var 14 =
   7 2:: digits:: killer:: dup var 126 =
   7 3:: digits:: killer:: dup var 22 =
   8 2:: digits:: killer:: dup var 238 =
   8 3:: digits:: killer:: dup var 62 =
   9 2:: digits:: killer:: dup var 510 =
   9 3:: digits:: killer:: dup var 126 =
  10 2:: digits:: killer:: dup var 990 =
  10 3:: digits:: killer:: dup var 254 =
  10 4:: digits:: killer:: dup var 30 =
  11 2:: digits:: killer:: dup var 1020 =
  11 3:: digits:: killer:: dup var 510 =
  11 4:: digits:: killer:: dup var 46 =
  12 2:: digits:: killer:: dup var 952 =
  12 4:: digits:: killer:: dup var 126 =
  13 2:: digits:: killer:: dup var 1008 =
  13 4:: digits:: killer:: dup var 254 =
  14 2:: digits:: killer:: dup var 864 =
  14 4:: digits:: killer:: dup var 510 =
  15 2:: digits:: killer:: dup var 960 =
  15 5:: digits:: killer:: dup var 62 =
  16 2:: digits:: killer:: dup var 640 =
  16 5:: digits:: killer:: dup var 94 =
  17 2:: digits:: killer:: dup var 768 =
  17 5:: digits:: killer:: dup var 254 =
  18 5:: digits:: killer:: dup var 510 =
  19 3:: digits:: killer:: dup var 1020 =
  20 3:: digits:: killer:: dup var 1016 =
  21 3:: digits:: killer:: dup var 1008 =
  21 6:: digits:: killer:: dup var 126 =
  22 3:: digits:: killer:: dup var 992 =
  22 6:: digits:: killer:: dup var 190 =
  23 3:: digits:: killer:: dup var 832 =
  23 6:: digits:: killer:: dup var 510 =
  24 3:: digits:: killer:: dup var 896 =
  26 4:: digits:: killer:: dup var 1020 =
  27 4:: digits:: killer:: dup var 1016 =
  28 4:: digits:: killer:: dup var 1008 =
  28 7:: digits:: killer:: dup var 254 =
  29 4:: digits:: killer:: dup var 928 =
  29 7:: digits:: killer:: dup var 382 =
  30 4:: digits:: killer:: dup var 960 =
  32 5:: digits:: killer:: dup var 1020 =
  33 5:: digits:: killer:: dup var 1016 =
  34 5:: digits:: killer:: dup var 976 =
  35 5:: digits:: killer:: dup var 992 =
  36 8:: digits:: killer:: dup var 510 =
  37 6:: digits:: killer:: dup var 1020 =
  37 8:: digits:: killer:: dup var 766 =
  38 6:: digits:: killer:: dup var 1000 =
  38 8:: digits:: killer:: dup var 894 =
  39 6:: digits:: killer:: dup var 1008 =
  39 8:: digits:: killer:: dup var 958 =
  40 8:: digits:: killer:: dup var 990 =
  41 7:: digits:: killer:: dup var 1012 =
  41 8:: digits:: killer:: dup var 1006 =
  42 7:: digits:: killer:: dup var 1016 =
  42 8:: digits:: killer:: dup var 1014 =
  43 8:: digits:: killer:: dup var 1018 =
  44 8:: digits:: killer:: dup var 1020 =
} =

killerConstraint fn:: dup var { function
  cage var
  i var
  n var
  empty var
  sum var
  v var
  r var
  c var
  p var

  // Is this cell in a cage?
  row.value col.value:: killer:: initialised {
    // Yes.
    cage row.value col.value:: killer:: =

    // Is this digit not one that can appear in this cage?
    n count cage.value:: killer:: =
    sum sum cage.value:: killer:: =           // The cage's given sum.
    sum 0 != {
      p sum.value n.value:: digits:: killer:: &=
      p-> initialised {
        p-> 1 num << & not { false return } ifthen
      } ifthen
    } ifthen

    // Go through each cell and tally the sum and check for duplicate entries.
    empty 0 =
    sum 0 =
    i 0 =
    { i n < } {
      r row i.value:: cage.value:: killer:: =
      c col i.value:: cage.value:: killer:: =
      v r.value$ c 10 + $ / 10 % =
      num v == { false return } ifthen        // Duplicate.
      v 0 == { empty++ } { sum sum v + = } if
      i++
    } while

    // If we have a sum given for this cage, then check it.
    n sum cage.value:: killer:: =             // The cage's given sum.
    n 0 != {
      sum num + n
      empty 1 == {
        // If there is 1 empty cell then it must be ours, so the sum must be exact.
        ==
      } {
        // If there are more empty cells then we can't exceed the total.
        <
      } if
      return
    } ifthen

  } ifthen

  true
} =

diagonalTLBRConstraint fn:: dup var { function
  i dup var 0 =
  c var

  row col == {
    { i 9 < } {
      c i.value$ i 10 + $ / 10 % =
      c num == { false return } ifthen
      i++
    } while
  } ifthen

  true
} =

diagonalBLTRConstraint fn:: dup var { function
  i dup var 0 =
  n dup var 1 num << =
  c var

  8 row - col == {
    { i 9 < } {
      c 8 i - $ i 10 + $ / 10 % =
      c num == { false return } ifthen
      i++
    } while
  } ifthen

  true
} =

oddEvenConstraint fn:: dup var {
  row.value col.value:: oddEven:: initialised {
    num 2 % row.value col.value:: oddEven:: ==
  } {
    true
  } if
} =

disjointSetsConstraint fn:: dup var { function
  x var
  y var
  r var
  c var

  x row 3 % =
  y col 3 % =

  r 0 =
  { r 9 < } {
    c 0 =
    { c 9 < } {
      r x + $ c y + 10 + $ / 10 % num == { false return } ifthen
      c c 3 + =
    } while
    r r 3 + =
  } while

  true
} =

palindromeConstraint fn:: dup var {
  row row.value:: col.value:: same:: initialised {
    r dup var row row.value:: col.value:: same:: =
    c dup var col row.value:: col.value:: same:: =
    n dup var r.value$ c 10 + $ / 10 % =
    n 0 == { n num == } or
  } {
    true
  } if
} =

// Very simple naked singles detector.
nakedSingles fn:: dup var {
  r var
  c var
  f var
  v var
  n var
  ns var
  count var
  changes dup var 0 =

  r 0 =
  { r 9 < } {
    v r.value$ =
    f 1 =
    c 0 =
    { c 9 < } {
      count 0 =
      n 1 =
      { n 10 < } {
        v f / 10 % 0 == { r.value c.value n.value possible fn::() } and {
          ns n =
          count++
        } ifthen
        n++
      } while
      count 1 == {
        r.value$ r.value$ ns f * + =
        changes++
        c 9 =
        r -1 =
      } {
        f f 10 * =
        c++
      } if
    } while
    r++
  } while
} =

startSingle dup var {
  r var
  c var
  f var

  // The grid.
  0$ var 1$ var 2$ var 3$ var 4$ var 5$ var 6$ var 7$ var 8$ var

  // Conversion from column number to factor. Add 10 to the column number.
  10$ dup var         1 =
  11$ dup var        10 =
  12$ dup var       100 =
  13$ dup var      1000 =
  14$ dup var     10000 =
  15$ dup var    100000 =
  16$ dup var   1000000 =
  17$ dup var  10000000 =
  18$ dup var 100000000 =

  r 0 =
  { r 9 < } {
    r.value$ 0 =
    f 1 =
    c 0 =
    { c 9 < } {
      r.value$ r.value$ r.value c.value:: grid:: f * + =
      f f 10 * =
      c++
    } while
    r++
  } while

  nakedSingles fn::()
  solve fn::()
} =

startThread dup var {
  tn dup var swap =
  r var
  c var
  f var
  cell var
  fr var
  fc var
  firstFlag dup var true =

  // The grid.
  0$ var 1$ var 2$ var 3$ var 4$ var 5$ var 6$ var 7$ var 8$ var

  // Conversion from column number to factor. Add 10 to the column number.
  10$ dup var         1 =
  11$ dup var        10 =
  12$ dup var       100 =
  13$ dup var      1000 =
  14$ dup var     10000 =
  15$ dup var    100000 =
  16$ dup var   1000000 =
  17$ dup var  10000000 =
  18$ dup var 100000000 =

  r 0 =
  { r 9 < } {
    r.value$ 0 =
    f 1 =
    c 0 =
    { c 9 < } {
      cell r.value c.value:: grid:: =
      r.value$ r.value$ cell f * + =
      firstFlag { cell 0 == } and {
        fr r =
        fc c =
        firstFlag false =
      } ifthen
      f f 10 * =
      c++
    } while
    r++
  } while

  // Can we put our thread number in the grid?
  firstFlag not {
    fr.value fc.value tn.value possible fn::() {
      fr.value$ fr.value$ tn fc 10 + $ * + =   // Put our thread number in and start the solve.
      nakedSingles fn::()
      solve fn::()
    } ifthen
  } ifthen

  mutex lock thread::()
  tn.value th:: 2 =
  mutex unlock thread::()

  main post thread::()
} =

possible fn:: dup var { function
  num dup var swap =
  col dup var swap =
  row dup var swap =
  r var
  c var
  f var
  v var

  // Check the row.
  v row.value$ =
  f 1 =
  c 0 =
  { c 9 < } {
    v f / 10 % num == { false return } ifthen
    f f 10 * =
    c++
  } while

  // Check the column.
  f col 10 + $ =
  r 0 =
  { r 9 < } {
    r.value$ f / 10 % num == { false return } ifthen
    r++
  } while

  // Check the region.
  regionChecker fn::() not { false return } ifthen

  // Check the constraints
  constraint fn::()
} =

solve fn:: dup var { function
  r var
  c var
  f var
  v var
  n var

  r 0 =
  { r 9 < } {
    v r.value$ =
    f 1 =
    c 0 =
    { c 9 < } {
      v f / 10 % 0 == {
        n 1 =
        { n 10 < } {
          r.value c.value n.value possible fn::() {
            r.value$ v n f * + =
            solve fn::()
            r.value$ v =
          } ifthen
          n++
        } while
        return
      } ifthen
      f f 10 * =
      c++
    } while
    r++
  } while

  threads initialised { threads 1 > } and {
    mutex lock thread::()
  } ifthen

  printSolution fn::()

  threads initialised { threads 1 > } and {
    mutex unlock thread::()
  } ifthen
} =

found dup var false =

// As mentioned above, this is the example taken from the Computerphile video.
whichSudoku 1 == {
  found true =
  "From Computerphile: https://www.youtube.com/watch?v=G_UYXzGuqvM" println

  regionChecker fn:: standardRegions fn:: =

  grid 0 5 3 0 0 7 0 0 0 0 setRow()
  grid 1 6 0 0 1 9 5 0 0 0 setRow()
  grid 2 0 9 8 0 0 0 0 6 0 setRow()
  grid 3 8 0 0 0 6 0 0 0 3 setRow()
  grid 4 4 0 0 8 0 3 0 0 1 setRow()
  grid 5 7 0 0 0 2 0 0 0 6 setRow()
  grid 6 0 6 0 0 0 0 2 8 0 setRow()
  grid 7 0 0 0 4 1 9 0 0 5 setRow()
  grid 8 0 0 0 0 8 0 0 7 9 setRow()
} ifthen

// From https://www.youtube.com/watch?v=MXUgYxHmKq4&t=0s
// This sudoku was featured on Cracking the Cryptic, and takes considerably longer than the one above.
whichSudoku 2 == {
  found true =
  "From Cracking the Cryptic: https://www.youtube.com/watch?v=MXUgYxHmKq4&t=0s" println

  regionChecker fn:: standardRegions fn:: =

  grid 0 0 6 8 0 0 0 0 1 3 setRow()
  grid 1 0 0 0 9 0 1 0 0 0 setRow()
  grid 2 0 0 0 0 0 8 0 0 4 setRow()
  grid 3 0 1 0 0 4 0 5 0 0 setRow()
  grid 4 0 3 0 0 0 9 0 0 0 setRow()
  grid 5 0 8 5 0 0 0 0 7 0 setRow()
  grid 6 0 2 0 0 0 7 3 0 0 setRow()
  grid 7 0 0 0 0 9 4 0 0 6 setRow()
  grid 8 4 0 0 0 6 0 0 0 0 setRow()
} ifthen

// From https://www.youtube.com/watch?v=rQHV-gIAG_0
// Another Cracking the Cryptic video, this one with a Knight's move constraint.
whichSudoku 3 == {
  found true =
  "From Cracking the Cryptic: https://www.youtube.com/watch?v=rQHV-gIAG_0" println
  "This includes a Chess Knight's move constraint." println

  regionChecker fn:: standardRegions fn:: =
  constraint fn:: { knightsMoveConstraint fn::() not { false return } ifthen } constraint fn:: + =

  grid 0 0 0 0 0 0 6 0 0 0 setRow()
  grid 1 0 0 3 0 0 0 0 0 7 setRow()
  grid 2 2 0 0 3 0 0 4 9 0 setRow()
  grid 3 6 0 0 0 0 0 0 4 5 setRow()
  grid 4 0 0 2 0 0 0 8 0 0 setRow()
  grid 5 0 0 0 1 0 0 0 0 0 setRow()
  grid 6 3 0 0 0 0 0 0 0 0 setRow()
  grid 7 7 0 0 0 0 1 0 0 9 setRow()
  grid 8 0 0 0 0 0 0 5 0 0 setRow()

} ifthen

// Another CTC sudoku: https://www.youtube.com/watch?v=vH-JooV8RA4&t=0s
whichSudoku 4 == {
  found true =
  "From Cracking the Cryptic: https://www.youtube.com/watch?v=vH-JooV8RA4&t=0s" println

  regionChecker fn:: standardRegions fn:: =

  grid 0 0 0 0 0 0 0 0 0 0 setRow()
  grid 1 0 0 9 8 0 0 0 0 7 setRow()
  grid 2 0 8 0 0 6 0 0 5 0 setRow()
  grid 3 0 5 0 0 4 0 0 3 0 setRow()
  grid 4 0 0 7 9 0 0 0 0 2 setRow()
  grid 5 0 0 0 0 0 0 0 0 0 setRow()
  grid 6 0 0 2 7 0 0 0 0 9 setRow()
  grid 7 0 4 0 0 5 0 0 6 0 setRow()
  grid 8 3 0 0 0 0 6 2 0 0 setRow()

} ifthen

// Another Cracking the Cryptic sudoku: https://www.youtube.com/watch?v=eJIu8w3ZXo8
// This is an irregular (jigsaw) sudoku.
whichSudoku 5 == {
  found true =
  "From Cracking the Cryptic: https://www.youtube.com/watch?v=eJIu8w3ZXo8" println
  "An irregular sudoku." println

  regionChecker fn:: irregularRegions fn:: =

  grid 0 3 0 0 0 0 0 0 0 1 setRow()
  grid 1 0 9 0 1 7 2 0 0 0 setRow()
  grid 2 0 0 3 0 0 0 9 0 0 setRow()
  grid 3 0 7 0 0 0 0 0 4 0 setRow()
  grid 4 0 4 0 0 3 0 0 6 0 setRow()
  grid 5 0 5 0 0 0 0 0 9 0 setRow()
  grid 6 0 0 6 0 0 0 5 0 0 setRow()
  grid 7 0 0 0 8 5 6 0 2 0 setRow()
  grid 8 7 0 0 0 0 0 0 0 8 setRow()

  regions 0 1 1 1 1 1 2 2 2 2 setRow()
  regions 1 1 3 3 3 6 6 2 2 2 setRow()
  regions 2 1 3 3 3 6 7 7 7 2 setRow()
  regions 3 1 3 3 3 6 7 7 7 2 setRow()
  regions 4 1 6 6 6 6 7 7 7 8 setRow()
  regions 5 9 6 4 4 4 8 8 8 8 setRow()
  regions 6 9 9 4 4 4 8 5 5 5 setRow()
  regions 7 9 9 4 4 4 8 5 5 5 setRow()
  regions 8 9 9 9 9 8 8 5 5 5 setRow()
} ifthen

// This is taken from Andrew Stuart's web site https://www.sudokuwiki.org/Daily_Jigsaw_Sudoku
// No. 4294, dated 13 Nov 2020. It is rated 5-star out of 6: Diabolical.
// The archived version is here: https://www.sudokuwiki.org/Print_Daily_Jigsaw.asp?day=13/11/2020
// At the time of writing, Andrew only archives sudoku's for 31 days, then they are deleted.
// The region layout is called "Andrew Stuart 24" and the numbering is taken directly
// from Andrew's solver page. A big thanks goes to Andrew for giving me permission to include this sudoku.
whichSudoku 6 == {
  found true =
  "From Andrew Stuart's web page: https://www.sudokuwiki.org/Daily_Jigsaw_Sudoku" println
  "Irregular sudoku, No. 4294, dated 13 Nov 2020" println

  regionChecker fn:: irregularRegions fn:: =

  grid 0 0 0 0 0 0 0 0 9 0 setRow()
  grid 1 5 0 0 0 8 1 0 0 0 setRow()
  grid 2 0 0 0 9 0 4 5 0 0 setRow()
  grid 3 0 0 0 0 0 0 0 0 5 setRow()
  grid 4 0 1 0 0 0 8 0 0 0 setRow()
  grid 5 7 0 6 0 0 0 0 0 0 setRow()
  grid 6 0 0 0 1 0 0 6 0 0 setRow()
  grid 7 1 0 0 7 2 0 0 0 0 setRow()
  grid 8 0 9 0 0 0 0 0 0 0 setRow()

  regions 0 1 1 2 2 2 2 3 3 4 setRow()
  regions 1 1 1 2 2 2 3 3 3 4 setRow()
  regions 2 1 1 1 2 3 3 3 4 4 setRow()
  regions 3 1 1 5 2 3 7 4 4 4 setRow()
  regions 4 5 5 5 6 6 7 7 4 4 setRow()
  regions 5 5 5 5 6 6 7 7 7 9 setRow()
  regions 6 8 5 5 6 6 7 7 7 9 setRow()
  regions 7 8 8 6 6 6 9 9 9 9 setRow()
  regions 8 8 8 8 8 8 8 9 9 9 setRow()
} ifthen

// Another CTC sudoku: https://www.youtube.com/watch?v=tTGXIa2IUrg
// Regular sudoku with an arrow constraint.
whichSudoku 7 == {
  found true =
  "From Cracking the Cryptic: https://www.youtube.com/watch?v=tTGXIa2IUrg" println
  "Arrow sudoku. The arrows are not shown, unfortunately." println

  regionChecker fn:: standardRegions fn:: =
  constraint fn:: { arrowConstraint fn::() not { false return } ifthen } constraint fn:: + =

  grid 0 0 0 0 5 0 4 0 0 0 setRow()
  grid 1 0 0 0 0 0 0 0 0 0 setRow()
  grid 2 0 7 0 0 0 0 0 0 0 setRow()
  grid 3 1 0 0 0 0 0 0 0 6 setRow()
  grid 4 0 0 0 0 0 0 0 0 0 setRow()
  grid 5 4 0 0 0 0 0 0 0 1 setRow()
  grid 6 0 0 0 0 0 0 0 5 0 setRow()
  grid 7 0 0 0 0 0 0 0 0 0 setRow()
  grid 8 0 0 0 3 0 8 0 0 0 setRow()

  0 0 newArrow()    0 1 arrowCell()   0 2 arrowCell()
  0 8 newArrow()    0 7 arrowCell()   0 6 arrowCell()
  1 3 newArrow()    1 4 arrowCell()   1 5 arrowCell()
  2 4 newArrow()    2 5 arrowCell()   2 6 arrowCell()
  3 3 newArrow()    3 2 arrowCell()   3 1 arrowCell()
  3 7 newArrow()    3 6 arrowCell()   3 5 arrowCell()
  5 1 newArrow()    5 2 arrowCell()   5 3 arrowCell()
  5 5 newArrow()    5 6 arrowCell()   5 7 arrowCell()
  6 2 newArrow()    6 3 arrowCell()   6 4 arrowCell()
  7 5 newArrow()    7 4 arrowCell()   7 3 arrowCell()
  8 0 newArrow()    8 1 arrowCell()   8 2 arrowCell()
  8 8 newArrow()    8 7 arrowCell()   8 6 arrowCell()
} ifthen

// A Cracking the Cryptic video: https://www.youtube.com/watch?v=ySPrdlfPHZs
// Standard sudoku with thermos.
// This is a standard region with thermo constraint sudoku.
whichSudoku 8 == {
  found true =
  "A Cracking the Cryptic video: https://www.youtube.com/watch?v=ySPrdlfPHZs" println
  "Standard sudoku with a thermo constraint." println
  "The thermos aren't shown, unfortunately." println

  regionChecker fn:: standardRegions fn:: =
  constraint fn:: { thermoConstraint fn::() not { false return } ifthen } constraint fn:: + =

  grid 0 1 0 0 7 0 0 0 0 0 setRow()
  grid 1 0 5 0 0 4 0 0 0 0 setRow()
  grid 2 0 0 0 0 0 1 0 0 0 setRow()
  grid 3 0 0 9 0 0 0 5 0 0 setRow()
  grid 4 0 0 0 8 0 0 0 0 0 setRow()
  grid 5 2 0 0 0 5 0 0 9 0 setRow()
  grid 6 0 0 0 0 0 5 0 0 0 setRow()
  grid 7 0 0 0 0 0 0 0 0 0 setRow()
  grid 8 0 0 0 0 0 0 0 2 0 setRow()

  0 1 newThermo()   1 1 thermoCell()    2 1 thermoCell()    3 1 thermoCell()
  0 6 newThermo()   1 6 thermoCell()    2 6 thermoCell()    3 6 thermoCell()
  1 8 newThermo()   2 8 thermoCell()    3 8 thermoCell()
  5 0 newThermo()   6 0 thermoCell()    7 0 thermoCell()    8 0 thermoCell()
  5 2 newThermo()   6 2 thermoCell()    7 2 thermoCell()    8 2 thermoCell()
  5 6 newThermo()   6 6 thermoCell()    7 6 thermoCell()
  8 8 newThermo()   8 7 thermoCell()    8 6 thermoCell()
} ifthen

// Another CTC sudoku. This is by Mitchell Lee, called Miracle Sudoku.
// https://www.youtube.com/watch?v=yKf9aUIxdb4
whichSudoku 9 == {
  found true =
  "Another Cracking the Cryptic sudoku: https://www.youtube.com/watch?v=yKf9aUIxdb4" println
  "Constructed by Mitchell Lee." println
  "This is called Miracle Sudoku, and includes King's and Knight's move constraints" println
  "and a non-consecutive constraint." println

  regionChecker fn:: standardRegions fn:: =
  constraint fn:: { kingsMoveConstraint      fn::() not { false return } ifthen } constraint fn:: + =
  constraint fn:: { knightsMoveConstraint    fn::() not { false return } ifthen } constraint fn:: + =
  constraint fn:: { nonconsecutiveConstraint fn::() not { false return } ifthen } constraint fn:: + =

  grid 0 0 0 0 0 0 0 0 0 0 setRow()
  grid 1 0 0 0 0 0 0 0 0 0 setRow()
  grid 2 0 0 0 0 0 0 0 0 0 setRow()
  grid 3 0 0 0 0 0 0 0 0 0 setRow()
  grid 4 0 0 1 0 0 0 0 0 0 setRow()
  grid 5 0 0 0 0 0 0 2 0 0 setRow()
  grid 6 0 0 0 0 0 0 0 0 0 setRow()
  grid 7 0 0 0 0 0 0 0 0 0 setRow()
  grid 8 0 0 0 0 0 0 0 0 0 setRow()
} ifthen

// Another CTC sudoku. This one has irregular regions and a kropki dot constraint.
// https://www.youtube.com/watch?v=ToC39GUmg5g
whichSudoku 10 == {
  found true =
  "Another Cracking the Cryptic sudoku: https://www.youtube.com/watch?v=ToC39GUmg5g" println
  "This is an irregular sudoku with kropki dot constraints." println

  regionChecker fn:: irregularRegions fn:: =
  constraint fn:: { kropkiConstraint fn::() not { false return } ifthen } constraint fn:: + =

  grid 0 0 0 0 4 0 6 0 0 0 setRow()
  grid 1 0 0 0 0 0 0 0 0 0 setRow()
  grid 2 0 0 0 0 0 0 0 0 0 setRow()
  grid 3 0 0 0 0 0 0 0 0 0 setRow()
  grid 4 0 0 0 0 0 0 0 0 0 setRow()
  grid 5 0 0 0 0 0 0 0 0 0 setRow()
  grid 6 0 0 0 0 2 0 0 0 0 setRow()
  grid 7 0 0 6 0 0 0 8 0 0 setRow()
  grid 8 0 0 0 0 1 0 0 0 0 setRow()

  regions 0 1 1 1 1 2 3 3 3 3 setRow()
  regions 1 4 1 1 2 2 2 3 3 5 setRow()
  regions 2 4 4 1 1 2 3 3 5 5 setRow()
  regions 3 4 4 4 1 2 3 5 5 5 setRow()
  regions 4 4 4 6 2 2 2 6 5 5 setRow()
  regions 5 4 7 6 6 6 6 6 8 5 setRow()
  regions 6 7 7 7 6 9 6 8 8 8 setRow()
  regions 7 7 7 9 9 9 9 9 8 8 setRow()
  regions 8 7 7 7 9 9 9 8 8 8 setRow()

  5 0 5 1 blackDot()
  5 7 5 8 blackDot()
  0 0 0 1 whiteDot()
  0 7 0 8 whiteDot()
  1 1 1 2 whiteDot()
  1 6 1 7 whiteDot()
  2 2 2 3 whiteDot()
  2 3 3 3 whiteDot()
  2 4 3 4 whiteDot()
  2 5 2 6 whiteDot()
  2 5 3 5 whiteDot()
  3 6 3 7 whiteDot()
  4 2 5 2 whiteDot()
  4 6 5 6 whiteDot()
  5 5 6 5 whiteDot()
  6 6 6 7 whiteDot()
} ifthen

whichSudoku 11 == {
  found true =
  "Another CTC video: https://www.youtube.com/watch?v=1QP7yviZYTU" println
  "This is by Phistomefel and is another take on the Miracle Sudoku." println
  "Negative-kropki dot and both main diagonal constraints." println

  regionChecker fn:: standardRegions  fn:: =
  constraint fn:: { negativeKropkiConstraint fn::() not { false return } ifthen } constraint fn:: + =
  constraint fn:: { diagonalTLBRConstraint   fn::() not { false return } ifthen } constraint fn:: + =
  constraint fn:: { diagonalBLTRConstraint   fn::() not { false return } ifthen } constraint fn:: + =

  grid 0 0 0 0 0 0 0 0 0 0 setRow()
  grid 1 0 0 0 0 0 0 0 0 0 setRow()
  grid 2 0 0 0 0 0 0 0 0 0 setRow()
  grid 3 0 1 0 0 0 0 0 2 0 setRow()
  grid 4 0 0 0 0 4 0 0 0 0 setRow()
  grid 5 0 0 0 0 0 0 0 0 0 setRow()
  grid 6 0 0 0 0 0 0 0 0 0 setRow()
  grid 7 0 0 0 0 0 0 0 0 0 setRow()
  grid 8 0 0 0 0 0 0 0 0 0 setRow()
} ifthen

whichSudoku 12 == {
  found true =

  // If you want to add your own sudoku, add it here.

  // You must include a region checker.
  // regionChecker fn:: standardRegions  fn:: =
  // regionChecker fn:: irregularRegions fn:: =

  // Include any additional contraint processors. Add the actual constraints, if any, later.
  // constraint fn:: { kingsMoveConstraint      fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { knightsMoveConstraint    fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { nonconsecutiveConstraint fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { arrowConstraint          fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { thermoConstraint         fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { kropkiConstraint         fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { negativeKropkiConstraint fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { xvConstraint             fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { negativeXVConstraint     fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { killerConstraint         fn::() not { false return } ifthen } constraint fn:: + = initKillerDigits()
  // constraint fn:: { diagonalTLBRConstraint   fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { diagonalBLTRConstraint   fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { oddEvenConstraint        fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { disjointSetsConstraint   fn::() not { false return } ifthen } constraint fn:: + =
  // constraint fn:: { palindromeConstraint     fn::() not { false return } ifthen } constraint fn:: + =

  // Row and column numbers start at 0, not 1 as is typical when discussing sudokus.
  // Row 0 is the top row and 8 the bottom. Column 0 is the left column and 8 the right.
  // Cell coordinates are always given row first then column. Keep these rules in mind when usng any of the
  // functions below.

  // Add the grid. Each grid line represents one row and looks like
  //  grid {r} {c0} {c1} ... {c8} setRow()
  // where {r} is the row number, and {c0} {c1} etc are the cell values of that row.
  // A zero value indicates an empty cell.

  // For irregular sudokus you enter the regions in a similar fashion to the grid.
  // You assign each region a unique number from 1 to 9, and then use the setRow()
  // function to add each row, like
  //  regions {r} {R1} {R2} ... {R9} setRow()
  // where {R1} {R2} etc are the region numbers you've assigned for each cell of the row.

  // To create an arrow you use newArrow() (the circle) followed by arrowCell() for each cell in the arrow.
  // You can have multiple arrows starting from the same cell by creating
  // new arrows from the same cell, eg
  //    4 5 newArrow()    4 6 arrowCell()   4 7 arrowCell()
  //    4 5 newArrow()    5 5 arrowCell()   6 5 arrowCell()     <-- start new arrow from same cell
  // and each cell may have multiple arrows pass through it.
  // Only single cell circles are supported. No pills.

  // Adding thermos is similar to arrows, where you start a new thermo (the bulb) from a given cell,
  // row first then column then call newThermo(). After that, add each cell of the thermo with
  // row column thermoCell(). The thermo cells must be added in sequence,
  // starting from the cell next to the bulb with the last being the tip. For example,
  //  4 7 newThermo()   3 7 thermoCell()    2 7 thermoCell()    2 6 thermoCell()

  // Adding kropki dots is done by giving the row and column of one cell and the row and column
  // of the other cell and calling blackDot() or whiteDot() as appropriate. Here's an example,
  // or check the sudoku example above.
  //  3 1 3 2 blackDot()
  //  8 0 8 1 whiteDot()

  // Adding XV consrtaints is similar to kropki dots where you specify the row and column of the
  // first cell, row and column of the connecting cell, then either call X() or V() as appropriate.
  //  4 1 5 1 X()
  //  4 0 4 1 V()

  // Adding killer cages is done with the killerCage() and killerCell() functions.
  // killerCage() takes one argument being the sum of the cage. If a cage has no sum given then
  // specify 0 as the sum. Folllowing that you call killerCell() for each cell comprising the cage.
  // For example,
  //  16 kiilerCage()   4 5 killerCell()    5 4 killerCell()    5 5 killerCell()
  // defines a 3-cell cage which sums to 16. For a cage with no sum given,
  //  0 killerCage()    5 6 killerCell()    6 5 kiillerCage()   6 6 killerCake()

  // To add an odd or even cells, give the cell coordinates followed by oddCell() or evenCell()
  //  5 3 oddCell()
  //  2 5 evenCell()

  // Adding palindrome lines is simply done by indicating which pairs of cells must have the same value.
  // You do this in a similar fashion to Kropki dots and X and V - specify the row and column of a pair
  // of cells that must have the same value, and call same():
  //  3 1 1 4 same()    3 2 2 4 same()
  // That's a 5-cell long palindrome, and because its length is odd you don't need to do anything
  // with the middle cell.

} ifthen

found {
  regionChecker fn:: initialised not {
    "You must select a region checker, either standardRegions or irregularRegions." println
    1 exit
  } ifthen

  optimiseRegions()
  printGrid()

  threads initialised { threads 1 > } and {
    tn var
    running var
    waiting var
    finished var
    states var
    i var

    thread library
    namespace library

    // Turn some of the namespaces static so they won't incur mutex contention overhead.
    grid static namespace::()
    region static namespace::()
    arrows static namespace::()
    thermos static namespace::()
    blackDot static namespace::()
    whiteDot static namespace::()
    X static namespace::()
    V static namespace::()
    killer static namespace::()
    oddEven static namespace::()
    same static namespace::()
    fn static namespace::()

    main semaphore thread::()
    mutex mutex thread::()

    i 1 =
    { i 10 < } {
      i.value th:: dup var 0 =
      i++
    } while

    states 0 =
    tn 1 =
    { tn threads <= } {
      tn.value th:: 1 =   // Running.
      tn.value startThread create thread::()
      tn++
      states states 10 * 1 + =
    } while

    i tn =
    { i 10 < } {
      states states 10 * =
      i++
    } while
    running tn 1 - =
    waiting 9 running - =
    finished 0 =

    { finished 9 != } {
      progress initialised { progress } and {
        mutex lock thread::()
        states finished waiting running now time::() dup timems time::() swap date time::() "%s %s running %d, waiting %d, finished %d, grid (thread) states %09d (0 = waiting, 1 = running, 2 = finished)\n" printf
        mutex unlock thread::()
      } ifthen

      main wait thread::()

      tn 10 < {   // Start new thread if some grids are unprocessed.
        tn.value th:: 1 =   // Running.
        tn.value startThread create thread::()
        tn++
      } ifthen

      // Check the status of all the threads.
      running 0 =
      waiting 0 =
      finished 0 =
      states 0 =
      i 1 =
      mutex lock thread::()
      { i 10 < } {
        i.value th:: value dup dup states 10 * + states swap = 0 == { waiting++ pop } { 1 == { running++ } { finished++ } if } if
        i++
      } while
      mutex unlock thread::()
    } while

    progress initialised { progress } and {
      mutex lock thread::()
      states finished waiting running now time::() dup timems time::() swap date time::() "%s %s running %d, waiting %d, finished %d, grid (thread) states %09d (0 = waiting, 1 = running, 2 = finished)\n" printf
      mutex unlock thread::()
    } ifthen
  } {
    startSingle()
  } if
} ifthen

endTime dup var now time::() =

"Total runtime was " print now time::() startTime vars:: - 1000.0 / dhms fn::() "" println
