#!/usr/local/bin/shale

// This solves a sudoku with:
//  row/column/3x3box constraints (standard sudoku)
//  row/column/irregular, or jigsaw, region constraints
// optionally with a Chess Knight's move constraint.
// It is based on the python code from the Computerphile video
//  https://www.youtube.com/watch?v=G_UYXzGuqvM
// The sudoku example from this video is used below, along with
// a couple of (commented-out) Cracking The Cryptic examples,
// and one irregular sudoku from Andrew Stuart's web page.

// The sudoku grid is stored in a multi-dimensional array under the grid:: namespace.
// The row and column of each cell is represented by:
//
//  row column:: grid::
//
// A 0 value represents an empty cell, and a 1 to 9 value represents a cell value.

// Increment a variable. Expects a variable name on the stack.
increment var
increment {
  dup 1 + =
} =

// Prnts the sudoku grid.
printGrid var
printGrid {
  r var
  c var

  r 0 =
  { r 9 < } {
    c 0 =
    { c 9 < } {
      r.value c.value:: grid:: dup 0 == { pop " ." } { " %d" } if printf
      c increment()
    } while
    "" println
    r increment()
  } while
} =

// Assign the cell values to one row of the grid.
setRow var
setRow {
  8$ var 8$ swap =    // cell 9 of the row
  7$ var 7$ swap =    // cell 8 of the row
  6$ var 6$ swap =    // ...
  5$ var 5$ swap =
  4$ var 4$ swap =
  3$ var 3$ swap =
  2$ var 2$ swap =
  1$ var 1$ swap =    // ...
  0$ var 0$ swap =    // cell 1 of the row
  r var r swap =      // the row number
  ns var ns swap &=   // the namespace to use
  i var               // loop counter

  r 0 < r 8 > or {
    r "Illegal row %d\n" printf
    1 exit
  } ifthen

  i 0 =
  { i 9 < } {
    i.value$ 0 < i.value$ 9 > or {
      i r i.value$ "Illegal value %d specified for r%dc%d\n" printf
      1 exit
    } ifthen
    r.value i.value:: ns->:: defined not {    // define this grid cell if not already defined
      r.value i.value:: ns->:: var
    } ifthen
    r.value i.value:: ns->:: i.value$ =       // assign the value to the grid cell
    i increment()
  } while
} =

// Standard 3x3 box region checker.
// This only works when called from within possile().
standardRegions var
standardRegions {
  r0 var
  c0 var

  r0 r 3 / 3 * =
  c0 c 3 / 3 * =
  i 0 =
  { i 3 < } {
    j 0 =
    { j 3 < } {
      r0 i + c0 j +:: grid:: n == {
        ok false =
        break
      } ifthen
      j increment()
    } while
    ok not { break } ifthen
    i increment()
  } while
} =

// Irregular region checker.
// This only works when called from within possile().
irregularRegions var
irregularRegions {
  region var
  i var

  0 r:: 1:: region:: initialised not { optimiseRegions() } ifthen

  region r.value c.value:: regions:: =   // Ths region we are in.

  i 0 =
  { i 9 < } {
    i.value r:: region.value:: region:: value i.value c:: region.value:: region:: value:: grid:: n == {
      ok false =
      break
    } ifthen
    i increment()
  } while
} =

// Convert the regions:: namespace into somethiing a little more cpu-time friendly.
optimiseRegions var
optimiseRegions {
  region var
  r var
  c var
  i var

  region 1 =
  { region 10 < } {
    i 0 =
    r 0 =
    { r 9 < } {
      c 0 =
      { c 9 < } {
        r.value c.value:: regions:: region == {
          i.value r:: region.value:: region:: var
          i.value c:: region.value:: region:: var
          i.value r:: region.value:: region:: r.value =
          i.value c:: region.value:: region:: c.value =
          i increment()
        } ifthen
        c increment()
      } while
      r increment()
    } while
    region increment()
  } while
} =

// Is it possible to place a digit in a given cell?
possible var
possible {
  n var n swap =
  c var c swap =
  r var r swap =
  i var
  j var
  ok var

  ok true =

  // Check the column doesn't already contain this value.
  i 0 =
  { i 9 < } {
    r.value i.value:: grid:: n == {
      ok false =
      break
    } ifthen
    i increment()
  } while

  // Check the row doesn't already contain this value.
  ok {
    i 0 =
    { i 9 < } {
      i.value c.value:: grid:: n == {
        ok false =
        break
      } ifthen
      i increment()
    } while

    // Check that the region doesn't already contain this value.
    ok {
      regionChecker()

      // Check for any other constraint.
      ok { constraint initialised { r c n constraint() not } and } and {
        ok false =
      } ifthen
    } ifthen
  } ifthen

  ok.value
} =

// This is a Knight's move constraint.
knightsMoveConstraint var
knightsMoveConstraint {
  0$ var 0$ swap =  // n
  1$ var 1$ swap =  // column
  2$ var 2$ swap =  // row
  nr var
  nc var
  ok var

  ok true =

  // Check Knight's move 2 left and 1 up and down.
  nc 1$ 2 - =
  nc 0 >= {
    nr 2$ 1 - =
    nr 0 >= {
      nr.value nc.value:: grid:: 0$ == {
        ok false =
      } ifthen
    } ifthen
    ok {
      nr 2$ 1 + =
      nr 9 < {
        nr.value nc.value:: grid:: 0$ == {
          ok false =
        } ifthen
      } ifthen
    } ifthen
  } ifthen

  // Check Knight's move 1 left and 2 up and down.
  ok {
    nc 1$ 1 - =
    nc 0 >= {
      nr 2$ 2 - =
      nr 0 >= {
        nr.value nc.value:: grid:: 0$ == {
          ok false =
        } ifthen
      } ifthen
      ok {
        nr 2$ 2 + =
        nr 9 < {
          nr.value nc.value:: grid:: 0$ == {
            ok false =
          } ifthen
        } ifthen
      } ifthen
    } ifthen
  } ifthen

  // Check Knight's move 1 right and 2 up and down.
  ok {
    nc 1$ 1 + =
    nc 9 < {
      nr 2$ 2 - =
      nr 0 >= {
        nr.value nc.value:: grid:: 0$ == {
          ok false =
        } ifthen
      } ifthen
      ok {
        nr 2$ 2 + =
        nr 9 < {
          nr.value nc.value:: grid:: 0$ == {
            ok false =
          } ifthen
        } ifthen
      } ifthen
    } ifthen
  } ifthen

  // Check Knight's move 2 right and 1 up and down.
  ok {
    nc 1$ 2 + =
    nc 9 < {
      nr 2$ 1 - =
      nr 0 >= {
        nr.value nc.value:: grid:: 0$ == {
          ok false =
        } ifthen
      } ifthen
      ok {
        nr 2$ 1 + =
        nr 9 < {
          nr.value nc.value:: grid:: 0$ == {
            ok false =
          } ifthen
        } ifthen
      } ifthen
    } ifthen
  } ifthen

  ok.value
} =

// Set this to standardRegions for the usual 3x3 boxes,
// or irregularRegions to handle irregular, or jigsaw, regions.
regionChecker var

// Leave this undefined to get the standard sudoku rules, or set this
// to constraint code such as knightsMoveConstraint defined above.
constraint var

solve var
solve {
  r var
  c var
  n var
  prt var

  prt true =
  r 0 =
  { r 9 < } {
    c 0 =
    { c 9 < } {
      r.value c.value:: grid:: 0 == {
        n 1 =
        { n 10 < } {
          r.value c.value n.value possible() {
            r.value c.value:: grid:: n =
            solve()
            r.value c.value:: grid:: 0 =
          } ifthen
          n increment()
        } while
        prt false =
        break
      } ifthen
      c increment()
    } while
    prt not { break } ifthen
    r increment()
  } while

  prt {
    "" println
    printGrid()
  } ifthen
} =

// As mentioned above, this is the example taken from the Computerphile video.
// Raspberry Pi3 Model A time: 22 seconds to finish, but the solution is output
// a little less than this.
//
regionChecker standardRegions =
grid 0 5 3 0 0 7 0 0 0 0 setRow()
grid 1 6 0 0 1 9 5 0 0 0 setRow()
grid 2 0 9 8 0 0 0 0 6 0 setRow()
grid 3 8 0 0 0 6 0 0 0 3 setRow()
grid 4 4 0 0 8 0 3 0 0 1 setRow()
grid 5 7 0 0 0 2 0 0 0 6 setRow()
grid 6 0 6 0 0 0 0 2 8 0 setRow()
grid 7 0 0 0 4 1 9 0 0 5 setRow()
grid 8 0 0 0 0 8 0 0 7 9 setRow()

// From https://www.youtube.com/watch?v=MXUgYxHmKq4&t=0s
// This sudoku was featured on Cracking The Cryptic, and takes considerably longer than the one above.
// Raspberry Pi3 Model A time: 18 minutes total elapsed time, although the
// solution only takes a couple of minutes to be produced. The rest of the time is spent
// looking for other, non-existant, solutions.
//
// regionChecker standardRegions =
// grid 0 0 6 8 0 0 0 0 1 3 setRow()
// grid 1 0 0 0 9 0 1 0 0 0 setRow()
// grid 2 0 0 0 0 0 8 0 0 4 setRow()
// grid 3 0 1 0 0 4 0 5 0 0 setRow()
// grid 4 0 3 0 0 0 9 0 0 0 setRow()
// grid 5 0 8 5 0 0 0 0 7 0 setRow()
// grid 6 0 2 0 0 0 7 3 0 0 setRow()
// grid 7 0 0 0 0 9 4 0 0 6 setRow()
// grid 8 4 0 0 0 6 0 0 0 0 setRow()

// From https://www.youtube.com/watch?v=rQHV-gIAG_0
// Another Cracking The Cryptic video, this one with a Knight's move constraint.
// Raspberry Pi3 Model A time: 54 seconds to the solution, and almost 7 minutes
// to complete.
//
// regionChecker standardRegions =
// constraint knightsMoveConstraint =
// grid 0 0 0 0 0 0 6 0 0 0 setRow()
// grid 1 0 0 3 0 0 0 0 0 7 setRow()
// grid 2 2 0 0 3 0 0 4 9 0 setRow()
// grid 3 6 0 0 0 0 0 0 4 5 setRow()
// grid 4 0 0 2 0 0 0 8 0 0 setRow()
// grid 5 0 0 0 1 0 0 0 0 0 setRow()
// grid 6 3 0 0 0 0 0 0 0 0 setRow()
// grid 7 7 0 0 0 0 1 0 0 9 setRow()
// grid 8 0 0 0 0 0 0 5 0 0 setRow()

// Another CTC sudoku: https://www.youtube.com/watch?v=vH-JooV8RA4&t=0s
// On a Pi3 Model A it takes a couple of minutes to produce the completed grid
// but takes an hour to finish.
//
// regionChecker standardRegions =
// grid 0 0 0 0 0 0 0 0 0 0 setRow()
// grid 1 0 0 9 8 0 0 0 0 7 setRow()
// grid 2 0 8 0 0 6 0 0 5 0 setRow()
// grid 3 0 5 0 0 4 0 0 3 0 setRow()
// grid 4 0 0 7 9 0 0 0 0 2 setRow()
// grid 5 0 0 0 0 0 0 0 0 0 setRow()
// grid 6 0 0 2 7 0 0 0 0 9 setRow()
// grid 7 0 4 0 0 5 0 0 6 0 setRow()
// grid 8 3 0 0 0 0 6 2 0 0 setRow()

// This is taken from Andrew Stuart's web site https://www.sudokuwiki.org/Daily_Jigsaw_Sudoku
// dated 13 Nov 2020. It is rated 5-star out of 6.
// The region layout is called "Andrew Stuart 24" and the numbering is taken directly
// from Andrew's solver page.
// The region numbers must be between 1 and 9 inclusive.
// Pi3 model A time: 33 minutes to the completed grid and 1h 35m to finish.
//
// regionChecker irregularRegions =
// regions 0 1 1 2 2 2 2 3 3 4 setRow()
// regions 1 1 1 2 2 2 3 3 3 4 setRow()
// regions 2 1 1 1 2 3 3 3 4 4 setRow()
// regions 3 1 1 5 2 3 7 4 4 4 setRow()
// regions 4 5 5 5 6 6 7 7 4 4 setRow()
// regions 5 5 5 5 6 6 7 7 7 9 setRow()
// regions 6 8 5 5 6 6 7 7 7 9 setRow()
// regions 7 8 8 6 6 6 9 9 9 9 setRow()
// regions 8 8 8 8 8 8 8 9 9 9 setRow()
// grid 0 0 0 0 0 0 0 0 9 0 setRow()
// grid 1 5 0 0 0 8 1 0 0 0 setRow()
// grid 2 0 0 0 9 0 4 5 0 0 setRow()
// grid 3 0 0 0 0 0 0 0 0 5 setRow()
// grid 4 0 1 0 0 0 8 0 0 0 setRow()
// grid 5 7 0 6 0 0 0 0 0 0 setRow()
// grid 6 0 0 0 1 0 0 6 0 0 setRow()
// grid 7 1 0 0 7 2 0 0 0 0 setRow()
// grid 8 0 9 0 0 0 0 0 0 0 setRow()

"Initial grid" println
printGrid()

solve()

// I'd like to see an irregular sudoku with a knight's constraint. Any takers...
