#!/usr/local/bin/shale

// Threads are implemented in the thread library

thread library

// The thread library provides POSIX thread support through
// the following function
//
//  create thread::()       create a new thread
//  mutex thread::()        create a new mutex
//  lock thread::()         lock a murtex
//  unlock thread::()       unlock a murex
//  semaphore thread::()    create a new semaphore
//  wait thread::()         wait on a semaphore
//  post thread::()         post to a semaphore



// Mutexes.

// Creating mutexes.

// To create a mutex you need to give it a name, which can be
// a number (integer or floating point), a string or a variable name.
// Here are some mutexes.

123 mutex thread::()
3.141 mutex thread::()
"Joe Bloggs" mutex thread::()
stop mutex thread::()
5 8:: a:: mutex thread::()

// All mutexes are stored under the mutex:: thread:: namespace,
// so you'll see them appear in the btree output (shown a little later).
// The value of each mutex is of no importance to your shale scipt.
// The value is the address of the dynamically allocated mutex.
// Change their value and disaster awaits.

// To lock a mutex, just do

123 lock thread::()

// And to unlock one:

123 unlock thread::()



// Semaphores.

// Creating a semaphore.

// Similar to mutexes, semaphores need a name.
// All of the following are valid sempahores.

123 semaphore thread::()
3.141 semaphore thread::()
"Joe Bloggs" semaphore thread::()
ready semaphore thread::()
5 8:: a:: semaphore thread::()

// All semaphors are stored under the semaphore:: thread:: namespace.
// And just like mutexes, the value of each semaphore is the address
// of the dynamically allocated semaphore.

// Waiting on and releassing a semaphore.

// To wait on a semaphore, push the semaphore's name and call wait thread::()
//
//  123 wait thread::()
//
// You can see these in action below.

// To release a semaphore, push the semaphore's name and call post thread::()
//
//  123 post thread::()



// Here you'll see the mutexes and semaphores stored in their
// respective namespace variables.

btree



// Creating a thread, and bringing it all together.

// To create a thread you need to pass in a function (or a code fragment).
// The thread will run until your function exits. While your function runs, the only
// access it has to the calling thread is via namespace variables. The thread has a
// completely separate stack and simple variable stack. You can synchronise your threads
// by using semaphores, and you can lock critical pieces of data structure
// stored in namespace variables with mutexes.

// In the following contrived example, the "main" thread will create two
// new threads and then wait on a semaphore. Each of the new threads will sit in
// a loop waiting for a bit, then update a namespace variable and wake up the main thread.
// And just for kicks each thread will use a mutex to prevent simultaneous access to
// a couple of namespace variables.

thread1 var
thread1 {
  i var

  1 ns:: var
  1 ns:: 0 =
  { true } {
    i 0 =
    { i 1000000 < } {       // waste a bit of time
      i++
    } while

    stop lock thread::()    // lock our important data structure
    1 ns::++                // really important task that must not be interrupted
    stop unlock thread::()  // and unlock it

    ready post thread::()   // wake up the main thread
  } while
} =

thread2 var
thread2 {
  i var

  2 ns:: var
  2 ns:: 0 =
  { true } {
    i 0 =
    { i 1250000 < } {
      i++
    } while

    stop lock thread::()
    2 ns::++
    stop unlock thread::()

    ready post thread::()
  } while
} =

thread1 create thread::()
thread2 create thread::()

"" println
i var
i 0 =
{ i 10 < } {
  ready wait thread::()

  stop lock thread::()
  1 ns:: 2 ns:: "%d %d\n" printf
  stop unlock thread::()

  i++
} while



// Closing comment.

// While the BTree that supports all namespace variables is thread-safe, most
// shale operator are not atomic, so something as simple as the ++ increment
// operator should be surrounded by a mutex lock/unlock should you have two
// or more threads changing the same variable.



micro version:: thread:: minor version:: thread:: major version:: thread:: "\nThread library version %d.%d.%d\n" printf
