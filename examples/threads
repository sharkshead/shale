#!/usr/local/bin/shale

// Threads are implemented in the thread library

thread library

// The thread library provides POSIX thread support through
// the following function
//
//  create thread::()       create a new thread
//  mutex thread::()        create a new mutex
//  lock thread::()         lock a murtex
//  unlock thread::()       unlock a murex
//  semaphore thread::()    create a new semaphore
//  wait thread::()         wait on a semaphore
//  post thread::()         post to a semaphore



// Mutexes.

// Creating mutexes.

// To create a mutex you need to give it a name, which can be
// a number (integer or floating point), a string or a variable name.
// Here are some mutexes.

123 mutex thread::()
3.141 mutex thread::()
"Joe Bloggs" mutex thread::()
stop mutex thread::()
5 8:: a:: mutex thread::()

// All mutexes are stored under the mutex:: thread:: namespace,
// so you'll see them appear in the btree output (shown a little later).
// The value of each mutex is of no importance to your shale scipt.
// The value is the address of the dynamically allocated mutex.
// Change their value and disaster awaits.

// To lock a mutex, just do

123 lock thread::()

// And to unlock one:

123 unlock thread::()



// Semaphores.

// Creating a semaphore.

// Similar to mutexes, semaphores need a name.
// All of the following are valid sempahores.

123 semaphore thread::()
3.141 semaphore thread::()
"Joe Bloggs" semaphore thread::()
ready semaphore thread::()
5 8:: a:: semaphore thread::()

// All semaphors are stored under the semaphore:: thread:: namespace.
// And just like mutexes, the value of each semaphore is the address
// of the dynamically allocated semaphore.

// Waiting on and releassing a semaphore.

// To wait on a semaphore, push the semaphore's name and call wait thread::()
//
//  123 wait thread::()
//
// You can see these in action below.

// To release a semaphore, push the semaphore's name and call post thread::()
//
//  123 post thread::()



// Here you'll see the mutexes and semaphores stored in their
// respective namespace variables.

btree



// Creating a thread, and bringing it all together.

// To create a thread you need to pass in a function (or a code fragment) and an argument.
// The argument can be any object and will be placed on the new thread's stack.
// The thread will run until the function exits. The thread has a completely separate stack
// and simple variable stack. You can synchronise your threads by using semaphores,
// and you can lock critical pieces of data structure stored in namespace variables with mutexes.
// Namespace variables are the only means by which different threads can exchange data.

// In the following contrived example, the "main" thread will create two
// new threads and then wait on a semaphore. Each new thread takes an argument which
// is a namespace variable, the value of which is the number of times it goes around
// a loop (effectively a time delay). It then reinitialises that variable to 0 and
// enters a loop where is waits for a bit, increments the namespace variable value
// then wakes up the main thread. The main thread terminates after 20 iterations.
// And just for kicks, each thread will use a mutex to prevent simultaneous access to
// a couple of namespace variables.

thread var
thread {
  p var p swap &=
  count var
  i var

  count p-> =
  p-> 0 =
  { true } {
    i 0 =
    { i count < } {       // waste a bit of time
      i++
    } while

    stop lock thread::()    // lock our important data structure
    p->++                   // really important task that must not be interrupted
    stop unlock thread::()  // and unlock it

    ready post thread::()   // wake up the main thread
  } while
} =

1 ns:: var
1 ns:: 100000 =
2 ns:: var
2 ns:: 125000 =

1 ns:: thread create thread::()
2 ns:: thread create thread::()

i var
i 0 =
{ i 20 < } {
  ready wait thread::()

  stop lock thread::()
  1 ns:: 2 ns:: "%d %d\n" printf
  stop unlock thread::()

  i++
} while



// Closing comment.

// While the BTree that supports all namespace variables is thread-safe,
// some shale operator are not. Something as simple as the ++ increment
// operator should be surrounded by a mutex lock/unlock should you have two
// or more threads changing the same variable. The "really important" example above
// isn't a case where a lock/unlock is required because p is pointing to different
// variables in the two threads; it is included solely as an example.



micro version:: thread:: minor version:: thread:: major version:: thread:: "\nThread library version %d.%d.%d\n" printf
